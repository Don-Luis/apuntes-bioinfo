---
title: "GWAS: Association analysis"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    self_contained: no
    number_sections: yes
    toc: yes
    toc_depth: 6
    toc_float:
      collapsed: no
---

After performing the quality control steps, we are closer to our final goal: perform association test, to identify associations between the response and the predictor variables. This is what we will do in this script

# Setup
```{r, setup}
Sys.setenv(PATH=paste0("/home/lsanchezg/Documents/programs/plink:",Sys.getenv("PATH")))
system("echo $PATH")
```

We will start copying or downloading the files generated by PLINK after the quality control process
```{bash}
ls ./HapMap_3_r3_10.* 
```

We also need to make sure that the needed packages are installed. If you don't have installed 'genio' and 'dplyr', please uncomment the commented lines
```{r}
#install.packages('genio', dependencies = TRUE)
library('genio')

#install.packages('dplyr')
library('dplyr')

#install.packages('ggplot2')
library('ggplot2')
```

# Preprocessing
To reduce time we are going to focus on associations in a subset of SNPs: SNPs that are in the first 10,000,000 base pairs of chromosome 1. Therefore, we need to filter these SNPs via command line:
```{bash}
awk '{ if ($1 == 1 && $4 < 10000000) print $2 }' HapMap_3_r3_10.bim > snps_in_chr1.txt
```

Or via R. In case you are working with Windows, it might be easier to use R to make this filter step. 
*Both lines (bash and r) generate the same output: snps_in_chr1.txt with as many rows as SNPs are in the first 10.000.000pb of chromosome 1.
```{r}
plink_files <- read_plink('HapMap_3_r3_10')
snps <- plink_files$bim  %>% filter(chr == 1, pos < 10000000) 

write.table(x = snps$id, file = 'snps_in_chr1.viaR.txt', col.names = F, row.names = F, quote=F, eol = "\n")
```


```{bash}
# checking both files are identical
cmp --silent snps_in_chr1.txt snps_in_chr1.viaR.txt && echo 'Files Are Identical' || echo "Files are different"
```

Once we have chosen the SNPs present in chromosome 1, we are going to use PLINK to filter these SNPs in the HapMap_3_r3_10 plink files
```{bash}
plink --bfile HapMap_3_r3_10 --extract snps_in_chr1.txt --make-bed --out HapMap_chr1
```

How can I check if I have applied the flag rightly?

# Bash
```{bash}
cat HapMap_chr1.bim | cut -f 1 | uniq # chromosomes presents in HapMap_chr1.bim file
cat HapMap_chr1.bim | wc -l # number of SNPs in HapMap_chr1.bim
cat snps_in_chr1.txt | wc -l # number of SNPs from chromosome_1
```

# R
```{r}
plink_files <- read_plink('HapMap_chr1')
unique(plink_files$bim$chr) # chromosomes presents in HapMap_chr1.bim file
dim(plink_files$bim)[1] # number of SNPs in HapMap_chr1.bim

snps <- read.table('snps_in_chr1.txt', header = F)
dim(snps)[1] # number of SNPs from chromosome_1 #3754
```

Now, we have the plink files with information of SNPs from chromosome 1. We will use R to generate a matrix that contains as many rows as individuals, and as many columns as SNPs we have in the dataset
```{r}
plink_files <- read_plink('HapMap_chr1')

allele_info <- genio::geno_to_char(plink_files$X, plink_files$bim) %>%
  as.data.frame %>%
  t(.) %>%
  as.data.frame
```

How many individuals and SNPs do we have?
```{r}
dim(allele_info) # 109 individuals | 3754 SNPs
```

# Simplest linear regression
The simplest model tries to estimate the association between one predictor (independent variable) and the response (dependent variable). As we have continuous data, we need to perform a linear regression model.

The generated dataframe (alele_info) just contains genotype information. However, to perform association analysis, we need to add information of the response variable to each individual. For this practice, we will simulate results from residual lung volume (RV: understood as the volume of air remaining in the lungs after a maximal exhalation), being 1.1-1.2 the average values in adults.
```{r}
set.seed(1)
allele_info$RV <- runif(nrow(allele_info), min=0.5, max=1.5)
```

Now, we have all to compute the linear regression model

## rs3131972
Let's start with just one SNP (rs3131972). If we show the alleles from this SNP, we will see three different genotypes:
```{r}
table(allele_info$rs3131972)
#A/A G/A G/G
#2   33  74 -> individuos con ese genotipo.
```
Diríamos que el alelo de referencia es el más común y el alelo alternativo el menos común. No obstante, plink tiene una función para capturar el alelo de referencia y alternativo, que es lo que comprobaremos a continuación.

Which is the homozygous reference, the heterozygous and the homozygous alternative genotype? Without any doubt, the heterozygous genotype will be 'G/A'. Paying attention to the frequency of the homozygous genotypes, we can assume that 'G/G' is the reference genotype and 'A/A' is the alternative one.

How can we check it?
```{r}
plink_files$bim %>% dplyr::filter(id == 'rs3131972')
```
Se ha confirmado lo que hemos predicho antes: A es el alelo alternativo y G el de referencia.

In this example, we are assuming a additive or co-dominant model (which means that each additional copy of alternative allele increases the risk disease additively). How can we transform this information into something interpretable by R? Factorising and ordering the factor
```{r}
allele_info$rs3131972 <- factor(allele_info$rs3131972, levels=c('G/G','G/A','A/A'), ordered=T)
allele_info$rs3131972
```

Now, we can compute the linear model, with the lm() function:
```{r}
model <- lm(formula = RV ~ rs3131972, data = allele_info)
coef(summary(model))
```
Cuando se mete una variable dependiente categórica ordenada, aparece .L (ajuste a una regresión lineal) y .Q (ajuste a una regresión cuadrática). En este caso, el p-valor no es significativo en ninguno de los casos, por lo que el modelo no se ajusta a ninguna regresión. 

Is there an association between residual volume and rs3131972?

### Visualizing results
```{r}
#sin recta de regresión
ggplot(allele_info, aes(x = rs3131972, y = RV, fill = rs3131972)) +
  geom_boxplot(position = position_dodge(width = 0.8), alpha = 0.5) +  
  # geom_jitter(aes(color = rs3131972), 
  #             position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8), 
  #             size = 3, alpha = 0.7) + 
  # stat_smooth(method = "lm", aes(group = 1), linetype = "dashed", size = .1, alpha = .5) +
  theme_minimal()

#con recta de regresión
ggplot(allele_info, aes(x = rs3131972, y = RV, fill = rs3131972)) +
  geom_boxplot(position = position_dodge(width = 0.8), alpha = 0.5) +  
  geom_jitter(aes(color = rs3131972),
              position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8),
              size = 3, alpha = 0.7) +
  stat_smooth(method = "lm", aes(group = 1), linetype = "dashed", size = .1, alpha = .5) +
  theme_minimal()
```

Parece que nuestros datos tienen mucha dispersión, por lo que el p-valor no es significativo.

## rs2281852
Let's study another SNP: rs2281852

To make sure how the alleles are ordered, we have to look into the bim file
```{r}
predictor <- snp <- 'rs2281852'

plink_files$bim %>% dplyr::filter(id == snp)
```

the reference allele is G; the alternative allele is T. 
```{r}
allele_info[[snp]] <- factor(allele_info[[snp]], levels=c('G/G','G/T','T/T'), ordered=T)
allele_info[[snp]]
```

```{r}
response <- 'RV'
formula <- as.formula(paste0(response, '~', snp)) 
#es necesario as.formula porque la clase de paste0 es caracter

model <- lm(formula, data = allele_info)
coef(summary(model))

```

What happens in this case?
En este caso, hay significancia para el modelo lineal. 

### Visualizing results
```{r}
ggplot(allele_info, aes(x = !!sym(predictor), y = !!sym(response), fill = !!sym(predictor))) +
  geom_boxplot(position = position_dodge(width = 0.8), alpha = 0.5) +  
  # geom_jitter(aes(color = !!sym(predictor)),
  #             position = position_jitterdodge(jitter.width = 0.2, dodge.width = 0.8),
  #             size = 3, alpha = 0.7) +
  # stat_smooth(method = "lm", aes(group = 1), linetype = "dashed", size = .1, alpha = .5) +
  theme_minimal()
```


# Multiple linear regression
Now we want to perform a more complex: a multiple linear regression in which we don't have only the SNPs information as the predictor variable, but also sex of the individuals as another covariate

We need to introduce sex information in the dataframe

Remember that FAM files contained sex information (1: male, 2: female, 0: unknown)
```{r}
head(plink_files$fam, n=3)
```
Vemos que tenemos el sexo en el archivo de plink codificado como 1 y 2, pero lo queremos codificar como male y female respectivamente.

```{r}
plink_files$fam %>% 
  dplyr::select(sex) %>%
  table(.)
```

The dataset contains 55 males and 54 females. We add sex info to the file with the SNPs information 
```{r}
sex_info <- plink_files$fam %>% dplyr::select(id, sex)

allele_info.sex <- merge(x = allele_info, 
                     y = sex_info, 
                     by.x = 'row.names',
                     by.y = 'id') %>%
                     rename('id' = 'Row.names')

table(allele_info.sex$sex)
```

As we prefer to have Male/Female values instead of 1/2, we will replaces the values by 'Male' or 'Female'
```{r}
allele_info.sex <- allele_info.sex %>%
  mutate(sex = case_when(sex == '1' ~ 'Male',
                         sex == '2' ~ 'Female')) %>%
  mutate(sex = as.factor(sex))

table(allele_info.sex$sex)
```

## rs3131972
Now, we can perform the analysis with two covariates (SNP and sex) to determine associations with residual lung volume (RV)
```{r}
model <- lm(RV ~ rs3131972 + sex, data = allele_info.sex)
coef(summary(model))
```
En este caso, ningún modelo es significativo.

## rs2281852
```{r}
model <- lm(RV ~ rs2281852 + sex, data = allele_info.sex)
coef(summary(model))
```
En este caso, el modelo lineal es significativo para la variable SNP, pero no para el sexo.

# Exercise:
Get the number of significative associations between the predictor ( _RV_ ) and the response variable (each _SNP_). You will have to perform several simple linear models (one for each SNP) and count the models with significant linear associations.

1. Order the alleles of each snp: hom.ref < het < hom.alt. As the reference and alternative alleles change within the snp, you might need to create a function that gets the alleles present in each snp and apply it to the whole dataset
```{r}
get_levels <- function(x) {

  ref_allele <- plink_files$bim %>% dplyr::filter(id == x) %>% select(ref)
  alt_allele <- plink_files$bim %>% dplyr::filter(id == x) %>% select(alt)
  
  hom.ref <- paste0(ref_allele, '/', ref_allele)
  het <-  paste0(ref_allele, '/', alt_allele)
  hom.alt <- paste0(alt_allele, '/', alt_allele)

  # return the alleles in the right order
  return(c(hom.ref, het, hom.alt))
}

# Loop to introduce the levels of each snp
for (i in as.vector(snps)) {
  snps[[i]] <- factor(snps[[i]], levels = get_levels(i) , ordered = TRUE)
}
```

2. Once the SNPs have their alleles ordered, you can perform the linear regression iteratively and store those SNPs with significant linear associations with the RV.
```{r}

```

