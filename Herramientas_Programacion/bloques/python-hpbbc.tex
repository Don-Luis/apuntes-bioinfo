%04/09 - Oscar Delgado - LE GUSTAN NOMBRES COMPLETOS DE VARIABLES !!!
\chapter{Programación en Python}
Los lenguajes de programación son la forma de comunicarnos con los ordenadores. Algunos lenguajes tienen bajo nivel de abstracción que trabajan en binario y por ello son más similares al propio sistema. Por otro lado, están los lenguajes de alto nivel de abstracción que son más cercanos al idioma humano. Python es el lenguaje con el mejor \textbf{balance entre potencia y simplicidad}. 

La máquina ejecuta un programa ejecutable (.exe), que está escrito en ensamblador, el lenguaje del ordenador. Para algunos lenguajes de programación, se requiere de un compilador para que genere a partir de nuestro código un ejecutable que entienda la máquina, como por ejemplo C. En el caso de Python, lo que requiere es un \textbf{intérprete}, que genera a tiempo real las instrucciones del ordenador para ejecutar nuestro código. El intérprete solía ser más lento que el compilador al tener que estar traduciendo a tiempo real el código. No obstante, a día de hoy, Python puede alcanzar un 90\% del tiempo que tardaría un programa escrito en C en ejecutarse. Esto se debe a que hay problemas paralelizables, es decir, que se pueden dividir en partes y realizar al mismo tiempo. El rendimiento de un programa depende de entrada-salida, es decir, la lectura de los datos que se encuentran en el disco duro, y eso depende de la tecnología del disco duro, no del lenguaje de programación. 

Python tiene un \textbf{gran soporte de librerías}, que son programas escritos por otras personas y que se pueden utilizar por los demás. Los comandos de Python se pueden escribir directamente desde la terminal (escribiendo primero \texttt{python3} y luego salir con ctrl d), pero eso no es cómodo. Es mejor crear primero un fichero fuente con extensión .py que luego pueda utilizar el intérprete. Para ello, se escribe \texttt{pico nombre.py}. Esto abre un editor de texto donde podemos escribir el código. Se guarda con ctrl s y se cierra con ctrl x. Para que el intérprete lo lea, se debe poner en la consola \texttt{python3 nombre.py}. En caso de que haya alguna errata o algún error en el código, a la hora de ejecutar el código por el intérprete se va a indicar en qué línea del código fuente se encuentra y qué problema hay. También existen\textbf{ programas o IDEs} que son entornos donde poder editar el código fuente de forma más intuitiva. Ejemplos son Visual Studio Code, PyCharm, Spider, etc. 

El código de Python se va ejecutando secuencialmente comando a comando. 

\section{Variables}
Las \textbf{variables} son contenedores donde guardar un contenido al que poder referirse mediante el nombre de la variable. El contenido puede ser desde números a cadenas de texto, lo que define el tipo de variable (el tipo de contenido que contiene una variable). En otros lenguajes, es necesario declarar una variable antes de poder usarla (se crea antes de meterle un contenido). Esto en Python no es necesario; la \textbf{creación de tipos es implícita por el intérprete en función del primer valor que se le dé a la variable}. Así, si se escribe directamente \texttt{age = 35}, el intérprete le da el tipo integer (número entero) a la variable age. Los \textbf{tipos en Python son implícitos y dinámicos} (pueden cambiar), lo que puede ser muy cómodo, pero también puede dar lugar a errores. Los tipos son:
\begin{itemize}
\item Integer: número entero
\item Float: número con decimales
\item String: cadena de caracteres, ya sean letras o números, que van entre comillas simples o dobles. Una vez que están definidas, ya no se pueden modificar.
\item Bool: booleanos, es decir, True o False.
\item List: lista
\item Tuple: tupla
\item Dictionary: diccionario
\end{itemize}

En cuanto a los nombres de las variables, no pueden contener espacios en blanco ni empezar por un número. Python es case-sensitive, por lo que hay una distinción entre mayúsculas y minúsculas. 

\section{Primeras nociones}
El comando \texttt{print} permite imprimir algo por pantalla. 

El comando \texttt{input} le pide información al usuario que debe aportar por teclado.
\begin{lstlisting}
name = input('Enter your name: ')
print('Hello, ', name)
\end{lstlisting}

Ese código está dividido en dos líneas de código. La primera línea es bloqueante, ya que le pide al usuario insertar por teclado su nombre. Una vez dado, ese nombre se asigna a la variable name que se emplea para imprimir por pantalla Hello y el nombre que se le ha insertado. 

Aunque los tipos de variables sean implícitos, se puede realizar un \textbf{casting}, es decir, especificar el tipo de la variable:
\begin{itemize}
\item str(variable): convierte en tipo string.
\item int(variable): convierte en tipo integer.
\item float(variable): convierte en tipo float.
\end{itemize}

Los comentarios en Python, marcados con \#, sirven para poner anotaciones para otras personas o nosotros mismos y que el intérprete va a omitir. Es buena práctica poner comentarios para explicar las partes del código.
\begin{lstlisting}
#Código de prueba
print('Esto es una prueba') #print
\end{lstlisting}

\section{Expresiones condicionales}
En Python, se pueden escribir condicionales: si algo es verdadero/falso, ocurre algo. Esto se hace mediante \texttt{if} y \texttt{else} y sirve para cambiar el flujo del programa o tomar decisiones.
\begin{lstlisting}
num_pensado = 4
num = input("Elige un número: ")

if num_pensado == num:
	print("Enhorabuena, has acertado")
else:
	print("Sigue intentando")
\end{lstlisting}

Si se cumple la condición del if, el código que se ejecuta es el que se encuentra indentado y se continúa sin ejecutarse el bloque else. Si no se cumple el if, el código que se ejecuta es el que se encuentra indentado tras else, y se omite el bloque del if. 

En el caso de que haya más condicionales, se puede utilizar \texttt{elif} seguido del siguiente condicional, siempre y cuando la condición sea de verdadero o falso:
\begin{lstlisting}
num_pensado = 4
num = input("Elige un número: ")

if num_pensado == num:
	print("Enhorabuena, has acertado")
elif num_pensado < num:
	print("No has acertado, el número es más bajo")
else:
	print("No has acertado, el número es más grande")
\end{lstlisting}

\subsection{Operadores condicionales}
Los operadores condicionales son aquellos que resultan en True o False. Los operadores son:
\begin{itemize}
\item x == y: x es igual a y. Un solo igual asigna el valor de una variable a otra, dos iguales comprueban si son lo mismo.
\item x != y: x no es igual a y.
\item x < y: x es menor que y.
\item x <= y: x es menor o igual que y.
\item x > y: x es mayor que y.
\item x >= y: x es mayor o igual que y. 
\end{itemize}

\subsection{Operadores lógicos}
Para poder incluir varios condicionales, se utilizan los operadores lógicos \textbf{and} y \textbf{or}. 

El operador \texttt{and} implica que las dos condiciones que se unen deben ser True para que el resultado sea True. Para el operador \texttt{or}, basta con que una condición sea True para que el resultado sea True.
\begin{table}[htbp]
	\centering
	\begin{tabularx}{0.5\textwidth}{XXcc}
	X & Y & X and Y & X or Y \\ \hline
	True & True & True & True \\
	True & False & False & True \\
	False & True & False & True \\
	False & False & False & False
	\end{tabularx}
\end{table}

\section{Bucles o loops}
Los bucles permiten repetir ciertas sentencias para ahorrar código redundante. 

\subsection{For loops}
Los for loops permiten repetir un código un \textbf{número determinado de veces}. La estructura típica de un for loop es:
\begin{lstlisting}
for variable in range(número inicial, número final, incremento):
	código que se quiere repetir
	
for variable in otra_variable:
	código a repetir
\end{lstlisting}

Es importante remarcar que el código que se quiere repetir debe estar indentado. Si no se pone número inicial, automáticamente empieza en 0. De igual forma, el incremento es 1 por defecto. El número final no está incluido. Por ello, si sólo se pone \texttt{range(número)}, se podría interpretar que se repite el bucle se repite el número indicado de veces. Por ejemplo, utilizando el ejemplo anterior, se podría escribir:
\begin{lstlisting}
num_pensado = 4

for i in range(5):
	num = input("Elige un número: ")
	if num_pensado == int(num):
		print("Enhorabuena, has acertado")
		break
	else:
		print("Sigue intentando")
\end{lstlisting}

La i es una variable que empieza en 0 y con cada iteración aumenta en uno hasta llegar a 4. Esto se hace automáticamente por el intérprete. Si se acierta el número antes, se sale del bucle mediante \texttt{break}.

\subsection{While loops}
Los bucles while se repiten un \textbf{número indeterminado de veces}. Este bucle depende de una condición:
\begin{lstlisting}
while condición:
	código que se quiere repetir
\end{lstlisting}

En estos bucles, es importante que la condición se modifique dentro del bucle para no crear un bucle infinito. 
\begin{lstlisting}
num_pensado = 4
fallo = True

while fallo == True:
	num = input("Elige un número: ")
	if num_pensado == num:
		print("Enhorabuena, has acertado")
		fallo = False
	else:
		print("Sigue intentando")
\end{lstlisting}
Así, cuando el usuario acierta el número, la variable fallo pasa a ser falsa y el bucle se interrumpe.

%06/09
\section{Cadenas o strings}
Las cadenas son cualquier secuencia de caracteres o números que se encuentran entre comillas simples o dobles. También hay cadenas vacías que no tienen ninguna secuencia entre las comillas. Las cadenas se pueden concatenar mediante el +. También se puede repetir el contenido de una cadena al multiplicarlo con las veces que se quiere repetir.
\begin{lstlisting}
'AB' + 'cd' # ABcd
'Hi' * 2 # HiHi 
\end{lstlisting}

Se puede calcular la longitud de una cadena mediante \texttt{len()}.  \marginpar[\footnotesize len] \
\begin{lstlisting}
cadena = "Hola"
len(cadena) #4
\end{lstlisting}

Para comprobar si una cadena contiene algo, se emplea el operador \texttt{in}. \marginpar[\footnotesize in \\ not in]  \ Para ver si no contiene algo, se usa \texttt{not in}. Esto realmente es una expresión booleana, ya que el resultado es verdadero o falso. 
\begin{lstlisting}
secuencia = "ATC"
if "G" in secuencia:
	print("La secuencia contiene guanina".)
else:
	print("La secuencia no contiene guanina.")
\end{lstlisting}

\subsection{F-strings}
A la hora de imprimir texto, es común alternar cadenas con valores de variables. Esto se puede hacer intercalando las cadenas entre comillas con las variables o con los denominados f-strings (format-strings). Los f-strings son expresiones con una sintaxis más fluida que permite darle formato a cadenas. Para imprimir el valor de variables, basta con poner el nombre de la variable entre llaves (\{\}). En caso de querer imprimir una llave en un f-string, se debe poner doble.
\begin{lstlisting}
variable = 1
print(f"El valor de la variable es {variable}.")
# Output: El valor de la variable es 1.
print(f"El valor de la variable es {{{variable}}}.")
# Output: El valor de la variable es {1}.
\end{lstlisting}

\subsection{Indexación y slicing}
Las cadenas se pueden indexar, es decir, referir a una posición en la misma cadena. Esto se realiza escribiendo la cadena (o la variable que contiene la cadena) seguido de la posición que se quiere entre corchetes. La primera posición es un 0, y las subsiguientes van incrementando en uno. A esto se le conoce como \textbf{indexación positiva}. 
\begin{lstlisting}
cadena = "hola"
cadena[0] #h
cadena[1] #o
cadena[2] #l
cadena[3] #a
\end{lstlisting}

La \textbf{indexación negativa} se refiere a acceder a la posición desde el final de la cadena. El último carácter es -1, y los siguientes van incrementando en 1. 
\begin{lstlisting}
cadena = "hola"
cadena[-1] #a
cadena[-2] #l
cadena[-3] #o
cadena[-4] #h
\end{lstlisting}

En algunas ocasiones, queremos acceder a un fragmento de una cadena. A esto se le conoce como \textbf{slicing}, y se emplea con las posiciones: \texttt{[primero:último:paso]}. La última posición no está incluida. Los pasos son opcionales, ya que tienen un valor por defecto de 1. Si se omite el primer valor, se empieza desde el primer caracter por defecto. Si se omite el último valor, se termina en el último caracter. Así, si se pone [:], se incluye todo el contenido.
\begin{lstlisting}
cadena = "hola"
cadena[1:3] #ol
cadena[::2] #hl
\end{lstlisting}

\subsection{Métodos de cadenas}
\begin{itemize}
\item lower(): devuelve la cadena con todas las letras en minúscula.
\item upper(): devuelve la cadena con todas las letras en mayúscula.
\item replace(s1, s2): reemplaza la primera cadena con la segunda.
\item count(x): cuenta el número de veces que se encuentra x.
\item index(x): devuelve la posición del primer x.
\item isalpha(): devuelve True si todos los caracteres de una cadena son letras.
\item eval(): evalúa la expresión matemática dentro de la cadena cuando el resultado es numérico.
\end{itemize}

\section{Estructuras de datos}
En Python hay cuatro estructuras de datos: listas, diccionarios, tuplas y conjuntos o sets. 

\subsection{Listas}
La lista es un \textbf{conjunto ordenado de objetos}. Pueden ser números, cadenas, booleanos, y se pueden mezclar los distintos tipos. El contenido de una lista se escribe entre corchetes y separando los distintos objetos por comas. 
\begin{lstlisting}
lista = [False, 1, 2, "tres"]
\end{lstlisting}

Las listas guardan algunas similitudes con las cadenas: \begin{itemize}
\item Son indexables y pueden sufrir slicing.
\item \texttt{len} muestra la cantidad de elementos que se encuentran en cadena.
\item El operador \texttt{in} muestra si la lista contiene algo.
\item Se puede concatenar listas mediante + y multiplicarlas con *.
\item Se pueden crear listas vacías con [].
\item Se puede iterar sobre ellas.
\end{itemize}
\begin{lstlisting}
codones = ['AAA', 'GCT', 'CCA']
for codon in codones:
	for nucleotido in codon:
		print(nucleotido)
\end{lstlisting}

Algunos métodos específicos para trabajar con listas son:
\begin{itemize}
\item \texttt{append(x}): añade x al final de la lista.
\item\texttt{sort()}: ordena la lista de forma alfabética si solo contiene letras y de pequeño a grande si solo contiene números. 
\item \texttt{count(x)}: devuelve el número de veces que aparece x en la lista.
\item \texttt{index(x)}: devuelve el índice del primer valor de x.
\item \texttt{reverse()}: revierte el orden de la lista.
\item \texttt{remove(x)}: elimina el primer x en la lista.
\item \texttt{pop(i)}: elimina el item en el índice i y devuelve su valor.
\item \texttt{insert(i,x)}: inserta x en el índice i de la lista.
\end{itemize}

\subsection{Diccionarios}
Los diccionarios son \textbf{conjuntos no ordenados de parejas de clave y valor}. Las claves deben ser únicas e inmutables de cadenas o números, ya que sirven para acceder al valor que tengan asignado. 
\begin{lstlisting}
dic_vacio = {} #Diccionario vacío
year ={'Enero':31, 'Febrero':28} #Diccionario de dos elementos
\end{lstlisting}

Se puede iterar sobre los diccionarios, pero el  elemento que se devuelve es la clave. Para que se devuelva el valor, se debe \textbf{indexar por la clave}:
\begin{lstlisting}
for month in year:
	print(month) # Imprime las claves
	print(year[month]) #Imprime los valores
\end{lstlisting}

Se pueden añadir o cambiar el valor de elementos de un diccionario mediante indexación de la clave. Si la clave no existe previamente en el diccionario, se crea con el valor que se le asigna. Si la clave ya existía, se actualiza su valor. Para eliminar elementos de un diccionario, se emplea \texttt{del()} y se indexa la clave que se quiere eliminar.

Se puede obtener una lista de todas las claves y de todos los valores con los métodos \texttt{.keys()} y \texttt{.values()} respectivamente. 

\section{Funciones}
Las funciones son una agrupación de líneas de código que se pueden ejecutar llamando el nombre de la funciones un número ilimitado de veces. De esa forma, las funciones permiten simplificar programas largos y mantenerlos. Además, eliminan código redundante. Es muy recomendable que las funciones se encuentren definidas antes de su llamada. Por convenio, todas las funciones se ponen en la parte superior del código, aunque sean llamadas solo al final. La estructura de una función es la siguiente:
\begin{lstlisting}
def nombre_funcion(argumento1, argumento2):
	código que ejecuta la función
\end{lstlisting}
El número de argumentos tiene que ser el mismo en la definición y en la llamada. No es necesario que los argumentos tengan el mismo nombre en la llamada y en la definición. Las \textbf{variables de la función son locales} y sólo se puede acceder a ellas dentro de la misma (en el ámbito de la función). 

La mayoría de las funciones devuelven un valor. Esto significa que una variable dentro de la función pase a estar disponible fuera de la misma. Para ello, se emplea \texttt{return}, el cual indica qué valor se devuelve. Cuando el código ejecuta un return, en ese momento termina la ejecución de la función, aunque haya más código posterior.
\begin{lstlisting}
def celsius_a_fahrenheit(temperatura_c):
	temperatura_f = temperatura_c * 9/5 + 32
	return temperatura_f
	
temp_c = 23
temp_f = celsius_a_fahrenheit(temp_c) 
#el valor de temp_c se pasa a la función y el valor de temperatura_f se le asigna a temp_f
\end{lstlisting}
Se pueden devolver varios valores en una función separándolos por comas. En la llamada, se pueden poner varias variables que se irán asignando en el mismo orden. Si alguna de las variables que se devuelven no se quieren guardar en una variable global, a la hora de asignar las variables se puede poner un guion bajo.
\begin{lstlisting}
def funcion(arg1, arg2, arg3):
	return arg3, arg2, arg1 
	
v1, v2, v3 = funcion(1, 2, 3) #v1 = 3, v2 = 2, v3 = 1
_, _, variable = funcion (1, 2, 3) # variable = 1
\end{lstlisting}
Las funciones no deberían escribirse para imprimir nada en pantalla, ya que entonces no sería reusable. Las funciones deberían ser modulares y autocompletadas: que reciban un valor y devuelvan un valor. Se puede hacer que una función imprima algún dato auxiliar en pantalla, pero esa no debería ser su función principal.

\subsection{Variables locales vs globales}
Las variables que se encuentran dentro de una función son variables locales, ya que no existen fuera del ámbito de la función. Por el contrario, variables globales están presentes en el código principal y existen en cualquier parte. Aunque se pueda tener una variable local que se llame igual a otra global sin que se afecten mutuamente, no es buena práctica hacer esto.

\subsection{Argumentos por defecto}
Es posible definir funciones que tengan argumentos por defecto. Esto hace que el argumento sea opcional, es decir, que en caso de no obtener un valor en la llamada, el argumento va a tener un valor predeterminado. Esto se utiliza en aquellas funciones en las que la mayoría de las veces un argumento tiene un valor. Así, solo en los casos excepcionales se debe indicar el valor, y en la mayoría de casos no se debe incluir en la llamada. Los parámetros opcionales se deben definir en la función siempre después de los parámetros obligatorios. 

\section{Librerías/módulos}
Muchas veces, vamos a necesitar importar librerías o módulos para nuestro código. Las librerías y los módulos son lo mismo; en informática, se solía hablar de librerías, pero en Python reciben el nombre de módulos. Para importar una librería, se emplea la siguiente estructura:
\begin{lstlisting}
import libreria
import libreria as lib
\end{lstlisting}
La diferencia entre la segunda línea y la primera es que en la primera, siempre se debe poner \texttt{libreria} cuando queramos usar una función que esté ella, mientras que en la segunda se le asigna el alias lib para no tener que escribir el nombre completo. Si solo se quiere importar una función de una librería, se puede escribir:
\begin{lstlisting}
from libreria import funcion
from libreria import funcion1, funcion2

libreria.funcion1()
\end{lstlisting}
Esto puede ser beneficioso si de una librería sólo se quiere importar una función, ya que actualmente hay librerías que ocupan mucho espacio y, dependiendo del código, puede ser ineficiente cargarla entera. 

\begin{table}[htbp]
\begin{mdframed}[backgroundcolor=black!10]
    \centering
    Un script en Python está organizado en tres bloques: la importación de librerías, la definición de funciones, y el código principal.
    \end{mdframed}
\end{table}

\subsection{Instalar nuevos módulos}
Desde la terminal, se puede instalar nuevos módulos de Python mediante el comando \texttt{pip install}. \marginpar[\footnotesize pip install]  \ Las librerías tienen su propia documentación en la que se detalla las funciones que tienen y cómo usarlas. Esta documentación puede estar disponible en internet o en un repositorio de GitHub. Hay que tener cuidado a la hora de instalar nuevos módulos, ya que pueden darse problemas de seguridad importantes. 

Las librerías tienen distintas versiones, por lo que se recomienda utilizar librerías que hayan sido actualizadas recientemente y haya mucha gente colaborando y mejorándola en el repositorio GitHub. Esto asegura que no esté anticuada y que tenga un número mínimo de errores, ya que la mayoría de errores se habrán solucionado ya por todos los usuarios. 

\subsection{Módulo random}
El módulo random cuenta con varias funciones que permiten obtener valores pseudoaleatorios. \marginpar[\footnotesize random \\ randint]  \ Por ejemplo, la función \texttt{randint()} saca un valor entero entre los valores inicial y final, ambos incluidos. 
\begin{lstlisting}
import random
print(random.randint(1, 10)) 
\end{lstlisting}

\subsection{Módulo requests}
El módulo requests permite interactuar con HTTP, es decir, con el formato de navegadores y páginas web. Probablemente lo vayamos a usar en el futuro para acceder a bases de datos biomédicas publicadas en la web. 

\subsection{Módulo sys}
El módulo sys permite acceder a algunas funciones del sistema. Por ejemplo, \texttt{sys.exit()} termina la ejecución de un script.

\section{Ficheros y directorios}
Trabajar con ficheros tiene un ciclo muy concreto: abrirlo, leerlo o escribirlo, y cerrarlo. Si se abren muchos ficheros y no se cierran, el ordenador se puede quedar sin memoria, por lo que es importante cerrarlos cuando ya no sean necesarios. 

Para \textbf{abrir un fichero} en Python, \marginpar[\footnotesize open() \\ readlines() \\ write() \\ close()]  \ se emplea \texttt{open(path/del/fichero, "modo")}. Modo hace referencia a cómo queremos abrir el fichero (el modo de lectura): para leer ("r"), escribir ("w"), leer y escribir ("rw") o append ("a"). Así, si solo queremos leer los datos de un fichero, lo abrimos con permisos de lectura y, al intentar escribir, daría un error. En la práctica, no hay diferencia entre los modos w y rw. Cuando se escribe en ficheros, se reescriben por completo; si queremos añadir texto al final del fichero, debemos usar el modo a que no sobreescribe el fichero. Para poder (sobre)escribir un fichero, se necesitan los permisos del sistema operativo para poder modificar el archivo. Para obtener las líneas que tiene el fichero, se utiliza el método \texttt{readlines()}. También se puede iterar sobre el fichero para obtener las líneas. Si queremos escribir en un fichero, se utiliza \texttt{write("contenido")}. Para cerrar un fichero una vez leído y modificado, se utiliza \texttt{close()}.
\begin{lstlisting}
fichero = open(ejemplo.txt) #el fichero se encuentra en el mismo directorio

contenido = fichero.readlines()
for line in fichero:
	print(line)
	
fichero.write("Nuevo contenido")
	
fichero.close()
\end{lstlisting}

\subsection{Ejercicio}
Escribir una función que escriba en un fichero una secuencia de ADN aleatoria de una longitud que reciba por parámetro.
\begin{lstlisting}
import random # alternativa: from random import choice

def escribe_secuencia_fichero(secuencia, nombre_fichero):
	fichero = open(nombre_fichero, "w")
	fichero.write(secuencia)
	fichero.close()

def generar_secuencia(longitud):
	bases = ["A", "T", "C", "G"] 
	secuencia_aleatoria = ""
	for i in range(longitud):
		secuencia_aleatoria += random.choice(bases)
	return secuencia_aleatoria
	
filename = "secuencia_aleatoria.txt"
num_bases = 10
secuencia = generar_secuencia(num_bases)
escribe_secuencia_fichero(secuencia, filename)
\end{lstlisting}

\section{Excepciones}
Una excepción es un \textbf{error irrecuperable}. Algunos errores en el programa son semánticos, es decir, son nuestros de programación. Estos son los peores porque aparentemente el programa funciona. Los errores irrecuperables hacen que el programa se detenga, como por ejemplo acceder a un fichero que no exista. Sabiendo que un código puede generar un error irrecuperable, se puede encapsular ese código dentro de una estructura especial:
\begin{lstlisting}
try:
	código que debe intentar
except Error: #ZeroDivisionError, PermissionError, IndexError, ...
	código que hacer entonces
\end{lstlisting}
Así, se captura la excepción y se da la oportunidad de hacer otra cosa. Para saber qué funciones pueden producir excepciones, se debe mirar la documentación, en la que se especifica también el tipo de error que se da. Se pueden dar varias excepciones con distintos errores para hacer el código más robusto.

Hay una excepción que recibe el nombre de Exception. Si se captura esta excepción, se captura cualquier tipo de error irrecuperable. El problema de esto es que aporta muy poca información de error y no se gestiona. Así, el programa no se para, pero tampoco se repara. Por tanto, hacer esto no es una buena práctica. 

Las excepciones pueden tener un else, el cual se ejecutará si no se lanza la excepción. De esa forma, no es necesario poner sys.exit(). Por último, existe la cláusula finally, la cual se ejecuta siempre, se lance o no una excepción. Esto es muy útil para cerrar ficheros (sobre todo si son grandes) y que no se queden en la memoria RAM cuando se da alguna excepción no capturada. 
\begin{lstlisting}
try:
	fichero = open("fichero.txt", "r")
except FileNotFoundError:
	print("El fichero no existe")
else:
	#código que podría fallar en algún momento
finally:
	fichero.close()
\end{lstlisting}

\section{Programación orientada a objetos}
Tradicionalmente, el código era lineal y se ejecutaba de forma lineal. La programación orientada a objetos presenta otro paradigma, ya que encapsula el código en objetos y clases para poder manipularlos directamente como si fuera un diccionario.