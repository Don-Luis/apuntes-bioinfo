%04/09 - Oscar Delgado - LE GUSTAN NOMBRES COMPLETOS DE VARIABLES !!!
\chapter{Programación en Python}
Los lenguajes de programación son la forma de comunicarnos con los ordenadores. Algunos lenguajes tienen bajo nivel de abstracción que trabajan en binario y por ello son más similares al propio sistema. Por otro lado, están los lenguajes de alto nivel de abstracción que son más cercanos al idioma humano. Python es el lenguaje con el mejor \textbf{balance entre potencia y simplicidad}. 

La máquina ejecuta un programa ejecutable (.exe), que está escrito en ensamblador, el lenguaje del ordenador. Para algunos lenguajes de programación, se requiere de un compilador para que genere a partir de nuestro código un ejecutable que entienda la máquina, como por ejemplo C. En el caso de Python, lo que requiere es un \textbf{intérprete}, que genera a tiempo real las instrucciones del ordenador para ejecutar nuestro código. El intérprete solía ser más lento que el compilador al tener que estar traduciendo a tiempo real el código. No obstante, a día de hoy, Python puede alcanzar un 90\% del tiempo que tardaría un programa escrito en C en ejecutarse. Esto se debe a que hay problemas paralelizables, es decir, que se pueden dividir en partes y realizar al mismo tiempo. El rendimiento de un programa depende de entrada-salida, es decir, la lectura de los datos que se encuentran en el disco duro, y eso depende de la tecnología del disco duro, no del lenguaje de programación. 

Python tiene un \textbf{gran soporte de librerías}, que son programas escritos por otras personas y que se pueden utilizar por los demás. Los comandos de Python se pueden escribir directamente desde la terminal (escribiendo primero \texttt{python3} y luego salir con ctrl d), pero eso no es cómodo. Es mejor crear primero un fichero fuente con extensión .py que luego pueda utilizar el intérprete. Para ello, se escribe \texttt{pico nombre.py}. Esto abre un editor de texto donde podemos escribir el código. Se guarda con ctrl s y se cierra con ctrl x. Para que el intérprete lo lea, se debe poner en la consola \texttt{python3 nombre.py}. En caso de que haya alguna errata o algún error en el código, a la hora de ejecutar el código por el intérprete se va a indicar en qué línea del código fuente se encuentra y qué problema hay. También existen\textbf{ programas o IDEs} que son entornos donde poder editar el código fuente de forma más intuitiva. Ejemplos son Visual Studio Code, PyCharm, Spider, etc. 

El código de Python se va ejecutando secuencialmente comando a comando. 

\section{Variables}
Las \textbf{variables} son contenedores donde guardar un contenido al que poder referirse mediante el nombre de la variable. El contenido puede ser desde números a cadenas de texto, lo que define el tipo de variable (el tipo de contenido que contiene una variable). En otros lenguajes, es necesario declarar una variable antes de poder usarla (se crea antes de meterle un contenido). Esto en Python no es necesario; la \textbf{creación de tipos es implícita por el intérprete en función del primer valor que se le dé a la variable}. Así, si se escribe directamente \texttt{age = 35}, el intérprete le da el tipo integer (número entero) a la variable age. Los \textbf{tipos en Python son implícitos y dinámicos} (pueden cambiar), lo que puede ser muy cómodo, pero también puede dar lugar a errores. Los tipos son:
\begin{itemize}
\item Integer: número entero
\item Float: número con decimales
\item String: cadena de caracteres, ya sean letras o números, que van entre comillas simples o dobles. Una vez que están definidas, ya no se pueden modificar.
\item Bool: booleanos, es decir, True o False.
\item List: lista
\item Tuple: tupla
\item Dictionary: diccionario
\end{itemize}

En cuanto a los nombres de las variables, no pueden contener espacios en blanco ni empezar por un número. Python es case-sensitive, por lo que hay una distinción entre mayúsculas y minúsculas. 

\section{Primeras nociones}
El comando \texttt{print} permite imprimir algo por pantalla. 

El comando \texttt{input} le pide información al usuario que debe aportar por teclado.
\begin{lstlisting}
name = input('Enter your name: ')
print('Hello, ', name)
\end{lstlisting}

Ese código está dividido en dos líneas de código. La primera línea es bloqueante, ya que le pide al usuario insertar por teclado su nombre. Una vez dado, ese nombre se asigna a la variable name que se emplea para imprimir por pantalla Hello y el nombre que se le ha insertado. 

Aunque los tipos de variables sean implícitos, se puede realizar un \textbf{casting}, es decir, especificar el tipo de la variable:
\begin{itemize}
\item str(variable): convierte en tipo string.
\item int(variable): convierte en tipo integer.
\item float(variable): convierte en tipo float.
\end{itemize}

Los comentarios en Python, marcados con \#, sirven para poner anotaciones para otras personas o nosotros mismos y que el intérprete va a omitir. Es buena práctica poner comentarios para explicar las partes del código.
\begin{lstlisting}
#Código de prueba
print('Esto es una prueba') #print
\end{lstlisting}

\section{Expresiones condicionales}
En Python, se pueden escribir condicionales: si algo es verdadero/falso, ocurre algo. Esto se hace mediante \texttt{if} y \texttt{else} y sirve para cambiar el flujo del programa o tomar decisiones.
\begin{lstlisting}
num_pensado = 4
num = input("Elige un número: ")

if num_pensado == num:
	print("Enhorabuena, has acertado")
else:
	print("Sigue intentando")
\end{lstlisting}

Si se cumple la condición del if, el código que se ejecuta es el que se encuentra indentado y se continúa sin ejecutarse el bloque else. Si no se cumple el if, el código que se ejecuta es el que se encuentra indentado tras else, y se omite el bloque del if. 

En el caso de que haya más condicionales, se puede utilizar \texttt{elif} seguido del siguiente condicional, siempre y cuando la condición sea de verdadero o falso:
\begin{lstlisting}
num_pensado = 4
num = input("Elige un número: ")

if num_pensado == num:
	print("Enhorabuena, has acertado")
elif num_pensado < num:
	print("No has acertado, el número es más bajo")
else:
	print("No has acertado, el número es más grande")
\end{lstlisting}

\subsection{Operadores condicionales}
Los operadores condicionales son aquellos que resultan en True o False. Los operadores son:
\begin{itemize}
\item x == y: x es igual a y. Un solo igual asigna el valor de una variable a otra, dos iguales comprueban si son lo mismo.
\item x != y: x no es igual a y.
\item x < y: x es menor que y.
\item x <= y: x es menor o igual que y.
\item x > y: x es mayor que y.
\item x >= y: x es mayor o igual que y. 
\end{itemize}

\subsection{Operadores lógicos}
Para poder incluir varios condicionales, se utilizan los operadores lógicos \textbf{and} y \textbf{or}. 

El operador \texttt{and} implica que las dos condiciones que se unen deben ser True para que el resultado sea True. Para el operador \texttt{or}, basta con que una condición sea True para que el resultado sea True.

\begin{table}[htbp]
	\centering
	\begin{tabularx}{0.5\textwidth}{XXcc}
	X & Y & X and Y & X or Y \\ \hline
	True & True & True & True \\
	True & False & False & True \\
	False & True & False & True \\
	False & False & False & False
	\end{tabularx}
\end{table}

\section{Bucles o loops}
Los bucles permiten repetir ciertas sentencias para ahorrar código redundante. 

\subsection{For loops}
Los for loops permiten repetir un código un \textbf{número determinado de veces}. La estructura típica de un for loop es:
\begin{lstlisting}
for variable in range(número inicial, número final, incremento):
	código que se quiere repetir
	
for variable in otra_variable:
	código a repetir
\end{lstlisting}

Es importante remarcar que el código que se quiere repetir debe estar indentado. Si no se pone número inicial, automáticamente empieza en 0. De igual forma, el incremento es 1 por defecto. El número final no está incluido. Por ello, si sólo se pone \texttt{range(número)}, se podría interpretar que se repite el bucle se repite el número indicado de veces. Por ejemplo, utilizando el ejemplo anterior, se podría escribir:
\begin{lstlisting}
num_pensado = 4

for i in range(5):
	num = input("Elige un número: ")
	if num_pensado == int(num):
		print("Enhorabuena, has acertado")
		break
	else:
		print("Sigue intentando")
\end{lstlisting}

La i es una variable que empieza en 0 y con cada iteración aumenta en uno hasta llegar a 4. Esto se hace automáticamente por el intérprete. Si se acierta el número antes, se sale del bucle mediante \texttt{break}.

\subsection{While loops}
Los bucles while se repiten un \textbf{número indeterminado de veces}. Este bucle depende de una condición:
\begin{lstlisting}
while condición:
	código que se quiere repetir
\end{lstlisting}

En estos bucles, es importante que la condición se modifique dentro del bucle para no crear un bucle infinito. 
\begin{lstlisting}
num_pensado = 4
fallo = True

while fallo == True:
	num = input("Elige un número: ")
	if num_pensado == num:
		print("Enhorabuena, has acertado")
		fallo = False
	else:
		print("Sigue intentando")
\end{lstlisting}
Así, cuando el usuario acierta el número, la variable fallo pasa a ser falsa y el bucle se interrumpe.

%06/09
\section{Cadenas o strings}
Las cadenas son cualquier secuencia de caracteres o números que se encuentran entre comillas simples o dobles. También hay cadenas vacías que no tienen ninguna secuencia entre las comillas. Las cadenas se pueden concatenar mediante el +. También se puede repetir el contenido de una cadena al multiplicarlo con las veces que se quiere repetir.
\begin{lstlisting}
'AB' + 'cd' # ABcd
'Hi' * 2 # HiHi 
\end{lstlisting}

Se puede calcular la longitud de una cadena mediante \texttt{len()}.  \marginpar[\footnotesize len] \
\begin{lstlisting}
cadena = "Hola"
len(cadena) #4
\end{lstlisting}

Para comprobar si una cadena contiene algo, se emplea el operador \texttt{in}. \marginpar[\footnotesize in \\ not in]  \ Para ver si no contiene algo, se usa \texttt{not in}. Esto realmente es una expresión booleana, ya que el resultado es verdadero o falso. 
\begin{lstlisting}
secuencia = "ATC"
if "G" in secuencia:
	print("La secuencia contiene guanina".)
else:
	print("La secuencia no contiene guanina.")
\end{lstlisting}

\subsection{F-strings}
A la hora de imprimir texto, es común alternar cadenas con valores de variables. Esto se puede hacer intercalando las cadenas entre comillas con las variables o con los denominados f-strings (format-strings). Los f-strings son expresiones con una sintaxis más fluida que permite darle formato a cadenas. Para imprimir el valor de variables, basta con poner el nombre de la variable entre llaves (\{\}). En caso de querer imprimir una llave en un f-string, se debe poner doble.
\begin{lstlisting}
variable = 1
print(f"El valor de la variable es {variable}.")
# Output: El valor de la variable es 1.
print(f"El valor de la variable es {{{variable}}}.")
# Output: El valor de la variable es {1}.
\end{lstlisting}

\subsection{Indexación y slicing}
Las cadenas se pueden indexar, es decir, referir a una posición en la misma cadena. Esto se realiza escribiendo la cadena (o la variable que contiene la cadena) seguido de la posición que se quiere entre corchetes. La primera posición es un 0, y las subsiguientes van incrementando en uno. A esto se le conoce como \textbf{indexación positiva}. 
\begin{lstlisting}
cadena = "hola"
cadena[0] #h
cadena[1] #o
cadena[2] #l
cadena[3] #a
\end{lstlisting}

La \textbf{indexación negativa} se refiere a acceder a la posición desde el final de la cadena. El último caracter es -1, y los siguientes van incrementando en 1. 
\begin{lstlisting}
cadena = "hola"
cadena[-1] #a
cadena[-2] #l
cadena[-3] #o
cadena[-4] #h
\end{lstlisting}

En algunas ocasiones, queremos acceder a un fragmento de una cadena. A esto se le conoce como \textbf{slicing}, y se emplea con las posiciones: \texttt{[primero:último:paso]}. La última posición no está incluida. Los pasos son opcionales, ya que tienen un valor por defecto de 1. Si se omite el primer valor, se empieza desde el primer caracter por defecto. Si se omite el último valor, se termina en el último caracter. Así, si se pone [:], se incluye todo el contenido.
\begin{lstlisting}
cadena = "hola"
cadena[1:3] #ol
cadena[::2] #hl
\end{lstlisting}

\subsection{Métodos de cadenas}
\begin{itemize}
\item lower(): devuelve la cadena con todas las letras en minúscula.
\item upper(): devuelve la cadena con todas las letras en mayúscula.
\item replace(s1, s2): reemplaza la primera cadena con la segunda.
\item count(x): cuenta el número de veces que se encuentra x.
\item index(x): devuelve la posición del primer x.
\item isalpha(): devuelve True si todos los caracteres de una cadena son letras.
\item eval(): evalúa la expresión matemática dentro de la cadena cuando el resultado es numérico.
\end{itemize}

\section{Estructuras de datos}
En Python hay cuatro estructuras de datos: listas, diccionarios, tuplas y conjuntos o sets. 

\subsection{Listas}
La lista es un \textbf{conjunto ordenado de objetos}. Pueden ser números, cadenas, booleanos, y se pueden mezclar los distintos tipos. El contenido de una lista se escribe entre corchetes y separando los distintos objetos por comas. 
\begin{lstlisting}
lista = [False, 1, 2, "tres"]
\end{lstlisting}

Las listas guardan algunas similitudes con las cadenas: \begin{itemize}
\item Son indexables y pueden sufrir slicing.
\item \texttt{len} muestra la cantidad de elementos que se encuentran en cadena.
\item El operador \texttt{in} muestra si la lista contiene algo.
\item Se puede concatenar listas mediante + y multiplicarlas con *.
\item Se pueden crear listas vacías con [].
\item Se puede iterar sobre ellas.
\end{itemize}
\begin{lstlisting}
codones = ['AAA', 'GCT', 'CCA']
for codon in codones:
	for nucleotido in codon:
		print(nucleotido)
\end{lstlisting}

Algunos métodos específicos para trabajar con listas son:
\begin{itemize}
\item \texttt{append(x}): añade x al final de la lista.
\item\texttt{sort()}: ordena la lista de forma alfabética si solo contiene letras y de pequeño a grande si solo contiene números. 
\item \texttt{count(x)}: devuelve el número de veces que aparece x en la lista.
\item \texttt{index(x)}: devuelve el índice del primer valor de x.
\item \texttt{reverse()}: revierte el orden de la lista.
\item \texttt{remove(x)}: elimina el primer x en la lista.
\item \texttt{pop(i)}: elimina el item en el índice i y devuelve su valor.
\item \texttt{insert(i,x)}: inserta x en el índice i de la lista.
\end{itemize}

\subsection{Diccionarios}
Los diccionarios son \textbf{conjuntos no ordenados de parejas de clave y valor}. Las claves deben ser únicas e inmutables de cadenas o números, ya que sirven para acceder al valor que tengan asignado. 
\begin{lstlisting}
#Diccionario de dos elementos
year ={'Enero':31, 'Febrero':28}
\end{lstlisting}

Se puede iterar sobre los diccionarios, pero el  elemento que se devuelve es la clave. Para que se devuelva el valor, se debe \textbf{indexar por la clave}:
\begin{lstlisting}
for mes in year:
	print(mes) # Imprime las claves
	print(year[mes]) #Imprime los valores
\end{lstlisting}

\section{Leer ficheros}
Para abrir un fichero en Python, se emplea \texttt{open(path/del/fichero)}. Para obtener las líneas que tiene el fichero, se utiliza el método \texttt{readlines()}.
\begin{lstlisting}
fichero = open(ejemplo.txt)
contenido = fichero.readlines()
\end{lstlisting}